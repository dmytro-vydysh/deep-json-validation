```ts
import { JVAny, JVArray, JVBigInt, JVBoolean, JVClass, JVDate, JVFile, JVNode, JVNumber, JVString, JV, JVCustom, JN, JVError, JVKeyError, JVKeyTypeError, JVKeyRegexError, JVKeyRequiredError } from 'deep-json-validation';
```

---

# deep-json-validation Example



**JV** - JSON Validator  
**JN** - JSON Navigator

üéØ Two separate goals, often working together. The library is simple, developer-friendly, and fully OOP.

---

## ‚úÖ JSON Validation Example

Imagine we need to validate a JSON object received via HTTP from a client:

```ts
// P.S.: All methods are chainable
// Required keys: require() or req()
// Optional keys: optional() or opt()

const MY_JSON_VALIDATOR = new JV()
  .require('name', new JVString())
  .req('lastname', new JVString())
  .optional('birthdate', new JVDate())
  .opt('sex', new JVString().setEnum(['male', 'female']))
  .opt('contatcs', new JVNode(new JV()
    .opt('email', new JVArray(new JVString().setRegex(/^[\w-]+(\.[\w-]+)*@([\w-]+\.)+[a-zA-Z]{2,7}$/))) // Surely you know a better regex than this üòÖ
    .opt('phone', new JVArray(new JVString().setRegex(/^\+?[0-9\s-]+$/).setNull()))
  ))
  .opt('skills', new JVArray(new JVNode(new JV()
    .req('name', new JVString())
    .req('level', new JVNumber().setMin(1).setMax(10))
    .opt('notes', new JVString().setNull())
  )));

const req = {
  body: {
    name: 'Dmytro',
    lastname: 'Vydysh',
    birthdate: '1998-10-27', // OR '1998-10-26T23:00:00.000Z' OR new Date(1998, 9, 27) OR 909442800000
    sex: 'male',
    contacts: {
      email: ['info@dmytrovydysh.com'],
      phone: [null],
    },
    skills: [
      { name: 'ToArriveLate', level: 10 },
      { name: 'UseChatGPTToGenerateDocumentation', level: 5, notes: 'Yes, this documentation is generated by ChatGPT' },
    ]
  }
};

const result = MY_JSON_VALIDATOR.validate(req.body); // returns true if valid, throws error otherwise
```

---

### ‚ö†Ô∏è Error Classes

```ts
const errorClasses = [
  JVError,            // Generic validation error
  JVKeyError,         // Error building the key path
  JVKeyTypeError,     // Invalid value type
  JVKeyRegexError,    // Regex did not match
  JVKeyRequiredError  // Missing required key
  // More errors coming in future versions
];
```

Example error message:
```
JVKeyError: [DEEP JSON VALIDATION] JSON validation failed!
Error: <JVError>The value 11 is greater than the maximum value 10</JVError>
Key address: skills/0/level
```

---

## üõ† Key Type Constructors

Each key type has its own class with configurable rules:

```ts
// Accepts any value
new JVAny()

// String
new JVString()
  .setNull(true) // Accepts: true, false, undefined. With true, allows null as valid
  .setRegex(/^[a-zA-Z0-9]+$/)
  .setEnum(['apple', 'banana', 'orange']);

// Number
new JVNumber()
  .setNull(true)
  .setMin(1)
  .setMax(10)
  .setEnum([1, 2, 3]);

// BigInt
new JVBigInt()
  .setNull(true)
  .setMin(1n)
  .setMax(10n)
  .setEnum([1n, 2n, 3n]);

// Boolean
new JVBoolean()
  .setNull(true);

// Date
new JVDate()
  .setNull(true)
  .setMin('2020-01-01')
  .setMax('2023-12-31')
  .setEnum(['2020-01-01', '2021-01-01', '2022-01-01']);

// File
// Based on your framework, you can override FILE_CLASS globally:
JV.FILE_CLASS = class MyCustomFile {};

new JVFile()
  .setNull(true)
  .setMaxSize(1024 * 1024 * 5)
  .setMimeTypes(['image/png', 'image/jpeg', 'application/*'])
  .setExtensions(['png', 'jpg', 'jpeg']);

// Array
new JVArray(new JVString())
  .setMin(1)
  .setMax(10);

// Node (nested structure)
new JVNode(new JV().req('key_name', new JVString()))
  .setNull(true);

// Custom
new JVCustom((value) => false); // Use a function to return true/false ‚Äî if false, it throws an error

// Class instance
class MyCustomClass {
  constructor(public name: string, public age: number) {}
}
new JVClass({ class: MyCustomClass })
  .setNull(true);
```

---

## üì¶ JSON Configuration Serialization

You can serialize your validator for reuse:

```ts
const myJSON_to_store = MY_JSON_VALIDATOR.json();
const myJSON_from_store = JV.fromJSON(myJSON_to_store);
```

> ‚ö†Ô∏è `JVCustom` and `JVClass` are not serializable and will throw if present.

---

## üß∞ Helpers

```ts
MY_JSON_VALIDATOR.template();       // Returns key structure template
MY_JSON_VALIDATOR.example();        // Returns example values
MY_JSON_VALIDATOR.exampleWithRules(); // Returns examples + applied rules
```

---

## üîé JSON Navigator (JN)

Make navigating JSON easier:

```ts
// Extract all key paths
const paths = JN.path(req.body);

// Extract paths with values
const values = JN.pathWithValues(req.body);

// Build a new object based on known paths
const materialized = JN.materialize({
  name: 'name',
  UseChatGPTToGenerateDocumentationSkillLevel: 'skills/1/level'
}, req.body, false);

// Extract a value by path
const value = JN.get(req.body, 'skills/1/level', false);
```

---

## üìö Final Notes

üß† This library was born out of the need for `.json()` and `.fromJSON()` ‚Äî the ability to persist validation logic.  
üí° The fluent and OOP-friendly structure makes it incredibly easy to use, read, and extend.

---

## üîó Links

GitHub: [https://github.com/dmytro-vydysh/deep-json-validation](https://github.com/dmytro-vydysh/deep-json-validation)  
Author: [https://dmytrovydysh.com](https://dmytrovydysh.com)  
Email: info@dmytrovydysh.com

---

üôè If you have questions, suggestions, or issues, open an issue or reach out directly.

**Enjoy validating!** üß™
